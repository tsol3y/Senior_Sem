# (C) Copyright IBM Corp. 2016
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.


__author__ = "Takayuki Osogami"


from abc import ABCMeta, abstractmethod
from .. import arraymath as amath
from collections import deque

import numpy as np


class Generator():

    """
    Abstract generator of time-series data

    Parameters
    ----------
    length : int, optional
        length of the sequence to be generated
        length = np.inf for unbounded sequence

    Attributes
    ----------
    limit : int
        length
    n : int
        length of the sequence already generated
    random : amath.random
        random number generator
    """

    __metaclass__ = ABCMeta

    def __init__(self, length=amath.inf):
        self.limit = length
        self.n = 0
        self.reset()

    def __iter__(self):
        return self

    def __next__(self):
        return self.next()

    def next(self):
        """
        Yield the next pattern

        Returns
        -------
        next pattern
        """
        if self.stopped():
            raise StopIteration()
        sample = self._get_sample()
        self._increment()
        return sample

    def reset(self, seed=0):
        """
        Resetting the state of the generator

        Parameters
        ----------
        seed : int, optional
            seed of random number generator
        """
        self.n = 0
        self.random = amath.random.RandomState(seed)

    def stopped(self):
        """
        Whether the limit is reached or not
        """
        return self.n >= self.limit

    def _increment(self):
        """
        Incrementing the step by 1
        """
        self.n += 1

    def add_length(self, length):
        """
        Increase the length of the sequence to generate

        Parameters
        ----------
        length : int
            amount of increase
        """
        self.limit += length

    def to_list(self, seed=0):
        """
        Getting a sequence of patterns generated by this generator

        Parameters
        ----------
        seed : int, optional
            seed of random number generator

        Returns
        ----------
        list
            list of patterns generated by this generator
        """
        if self.limit == amath.inf:
            print("Must have finite limit for to_list")
            return list()
        current_n = self.n
        current_state = self.random.get_state()
        self.reset(seed)
        sequence = list()
        for pattern in self:
            sequence.append(pattern)
        self.n = current_n
        self.random.set_state(current_state)
        return sequence

    @abstractmethod
    def _get_sample(self):
        """
        Getting the next sample
        """
        pass


class NoisySin(Generator):

    """
    Iterator of noisy sin wave

    Parameters
    ----------
    length : integer
        length of the series to be generated
    perod : integer
        period of the sin wave
    std : float
        standard deviation of noise (no noise if std<=0)
    dim : integer
        dimension of the series
    phase : array, shape(dim,), optonal
        initial phase of each dimension
    reverse : boolean, optional
        whether to generate a reverse sequence

    Attributes
    ----------
    period : int
        period
    std : int
        standard deviation
    dim : int
        dimension
    phase : array, shape(dim,)
        phase
    reverse : boolean
        whether to generate a reverse sequence
    """

    def __init__(self, length, period, std, dim, phase=None, reverse=False):
        if not period > 0:
            raise ValueError("period must be positive")
        if not dim > 0:
            raise ValueError("dim must be positive")
        self.period = period
        self.std = std
        self.dim = dim
        self.reverse = reverse
        if phase is None:
            self.phase = amath.zeros(dim)
        elif phase is "equal":
            self.phase = 2 * amath.pi * amath.arange(dim) / dim
        else:
            self.phase = phase
        if not self.phase.shape == (dim,):
            raise ValueError("shape of phase must be (dim,)")
        Generator.__init__(self, length)

    def _get_sample(self):
        """
        Getting the next pattern

        Returns
        -------
        sample : array, shape(dim,)
            next pattern
        """
        angle = 2. * amath.pi * self.n / self.period + self.phase
        if self.reverse:
            angle *= -1
        sample = amath.sin(angle)
        if self.std > 0:
            noise = self.random.normal(0, self.std, self.dim)
            return sample + noise
        else:
            return sample


class NoisySawtooth(Generator):

    """
    Iterator of noisy sawtooth wave

    Parameters
    ----------
    length : integer
        length of the series to be generated
    period : integer
        period of the sin wave
    std : float
        standard deviation of noise (no noise if std<=0)
    dim : integer
        dimension of the series
    phase : array, shape(dim,), optonal
        initial phase of each dimension
    reverse : boolean, optional
        whether to generate a reverse sequence

    Attributes
    ----------
    period :
        period
    std : int
        standard deviation
    dim : int
        dimension
    phase : array, shape(dim,)
        phase
    reverse : boolean
        whether to generate a reverse sequence
    """

    def __init__(self, length, period, std, dim, phase=None, reverse=False):
        if not period > 0:
            raise ValueError("period must be positive")
        if not dim > 0:
            raise ValueError("dim must be positive")
        self.period = period
        self.std = std
        self.dim = dim
        self.reverse = reverse
        if phase is None:
            self.phase = amath.zeros(dim)
        elif phase is "equal":
            self.phase = 2 * amath.pi * amath.arange(dim) / dim
        else:
            self.phase = phase
        if not self.phase.shape == (dim,):
            raise ValueError("shape of phase must be (dim,)")
        Generator.__init__(self, length)

    def _get_sample(self):
        """
        Getting the next pattern

        Returns
        -------
        sample : array, shape(dim,)
        """
        _phase = 1. * self.n / self.period + self.phase / amath.pi
        if self.reverse:
            _phase += -1
        sample = _phase % 1
        if self.std > 0:
            noise = self.random.normal(0, self.std, self.dim)
            return sample + noise
        else:
            return sample


class Uniform(Generator):

    """
    Iterator of unifomly random numbers

    Parameters
    ----------
    length : integer
        length of the series to be generated
    low : integer
        lower limit of the uniform random numbers
    high : integer
        upper limit of the uniform random numbers
    dim : integer
        dimension
    """

    def __init__(self, length, low, high, dim):
        self.low = low
        self.high = high
        self.dim = dim
        Generator.__init__(self, length)

    def _get_sample(self):
        """
        Getting the next pattern

        Returns
        -------
        sample : array, shape(dim,)
        """
        return self.random.uniform(low=self.low, high=self.high, size=self.dim)


class SliceGenerator(Generator):

    """
    Iterator of subvectors generated by a generator

    Parameters
    ----------
    generator : Generator
        generator to generate a whole vector
    begin : integer
        index of the beginning of the subvector to be iterated
    end : integer
        index of the end of the subvector to be iterated
    """

    def __init__(self, generator, begin, end):
        self.generator = generator
        self.begin = begin
        self.end = end

        self.limit = generator.limit
        self.n = generator.n

    def reset(self, seed=0):
        self.generator.reset(seed)

    def stopped(self):
        self.generator.stopped()

    def _increment(self):
        self.generator._increment()

    def _get_sample(self):
        """
        Getting the next subvector

        Returns
        -------
        array, shape(end-begin+1,)
        """
        sample = self.generator._get_sample()
        return sample[self.begin:self.end]


class ListGenerator(Generator):

    """
    Iterator over a list of generators

    Parameters
    ----------
    generators : list
        list of generators
    """

    def __init__(self, generators):
        limit = min([g.limit - g.n for g in generators])
        self.generators = generators
        Generator.__init__(self, limit)

    def _get_sample(self):
        return [g._get_sample() for g in self.generators]

    def _increment(self):
        for g in self.generators:
            g._increment()
        Generator._increment(self)

    def reset(self, seed=0):
        Generator.reset(self, seed)


class ElementGenerator(Generator):

    """
    Given an original generator of iterating over a sequence,
    ElementGenerator iterates over the sequence[index].

    Parameters
    ----------
    generator : iterator
        generator of array like patterns
    index : int
        index of the array like patterns to be generated

    Attributes
    ----------
    generator : iterator
        original generator
    index : int
        index
    limit : int
        length of the sequence to be generated
    n : int
        length of the sequence already generated
    """

    def __init__(self, generator, index):
        self.generator = generator
        self.index = index

        self.limit = generator.limit
        self.n = generator.n

    def reset(self, seed=0):
        self.generator.reset(seed)

    def stopped(self):
        self.generator.stopped()

    def _increment(self):
        self.generator._increment()

    def _get_sample(self):
        sample = self.generator._get_sample()
        return sample[self.index]


class SequenceGenerator(Generator):

    """
    Iterator over a sequence

    Parameters
    ----------
    sequence : list
        list of patterns to be generated

    Attributes
    ----------
    sequence : list
        list of patterns to be generated
    """

    def __init__(self, sequence):
        self.sequence = sequence
        Generator.__init__(self, len(sequence))

    def _get_sample(self):
        return amath.array(self.sequence[self.n])

    def reverse(self):
        """
        Getting a reverse sequence.
        This does not reset n.
        So if m patterns have already been generated, it givess m+1-st pattern
        of the reverse sequence in the next step.
        """
        self.sequence.reverse()

    def get_dim(self):
        """
        Getting the dimension of the sequence

        Returns
        -------
        int
            the dimension of the sequence
        """
        if len(self.sequence) > 0:
            return len(self.sequence[0])
        else:
            return None


class GaussianARGenerator(Generator):

    """
    Generator of Gaussian autoregressive model

    Parameters
    ----------
    length: int
        length of data

    coefficients: List[float]
        coefficient of autoregression

    Attributes
    ----------
    sequence : list
        list of patterns to be generated
    """

    def __init__(self, length, bias=0, coefficients=[], scale=1):
        Generator.__init__(self, length)
        self.bias = bias
        self.coefficients = np.asarray(coefficients)
        self.scale = scale
        d = len(coefficients)
        self.queue = deque(iterable=(0,) * d, maxlen=d)

    def _get_sample(self):
        noise = self.random.normal(loc=self.bias, scale=self.scale)
        val = noise + np.sum(np.asarray(self.queue) * self.coefficients)
        self.queue.appendleft(val)
        return np.array([val])

    def get_dim(self):
        return 1

